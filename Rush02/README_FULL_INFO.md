# Kак взаимодействуют файлы и функции


## Первым конечно запускается файл main.c

в нем обрабатывается проверка соответствия с условиями задачи.
при соответствии в зависимости от переданных аргументов функция ft_core из файла core.c запускается с разным вторым аргументом.

в core.c у нас 2 функции. Функция ядра и функция статичного хранения ссылки нашего массива (поскольку мы используем валидацию с помошью norminette у нас ограниченное количество передаваемых аргументов из-за чего будет затратно передавать ссылку на массив цепочкой аргументов.)

## core.c

static_save - хранит ссылку переданного массива если он не пустой (не NULL) и возвращает ту же ссылку назад. Чтобы получить только ссылку можно вызвать функцию просто передав в него NULL и получим ссылку которая хранится в статике.

ft_core - получает строку данных которые надо переобразовать в текстовый вариант и название файла шаблона с помошью которого он должен будет это реализовать.
в этой функции вызываются:

ft_read_file_data для прочтения данных из файла, при ошибке завершает программу.

ft_split_content для переобразования данных в двумерный массив символов.

static_save для хранения ссылки двумерного массива (используется для передачи в другие функции обходя передачу через аргументы)

free освобождаем память выделенной для прочтения данных из файла (они уже перемещены в двумерный массив)

ft_process_dict_data для реализации основной программы. В функцию передается строка которую необходимо переобразовать в текстовой вид, длина массива и глубину погружения (используется для подсчетя начала и конца массива с которой должна на данный момент работать процессные функции формулой (i * 3 <= len) для трехзначных чисел, ((i - 1) * 3 + 2 <= len) для двузначных и условие ((i - 1) * 3 + 1 <= len) для однозначных)

## process.c

ft_process_dict_data это рекурсивная функция, которая вызывается до тех пор пока не закончился переданная строка (на данном этапе данные уже проверены валидацией и данная функция не запустилась бы будь проблемы с валидацией). Она определяет формулами какая функция должна быть вызваа используя глубину погружения и длину переданного массива символов. Формула для трехзначных чисел уже была продемонстрирована выше.

ft_process_three
ft_process_two
ft_process_one функции выполняют роль процессной оброботки полученных трехзначных, двухзначных и однозначных данных соответственно. Если после обработки функции видят что переданный массив символов все еще не закончился он вызывает рекурсивно ft_process_dict_data с измененными данными которая в свою очередь вызовет их уже с измененными данными.
Эти три функции при окончании рекурсивных вызовов начинают поочередно методом LIFO (Last In First Out) вызывать функции печати из файла print.c

ft_count_digits используется для подсчета чисел, он вызывается в файле принт. Изначально он не должен был быть здесь, однако благодаря norminette и его ограничениям нам пришлось в спешке "впихнуть" его тут.

## print.c

ft_print_three
ft_print_two
ft_print_one функции вызываются из функций для трехзначных, двухзначных и однозначных данных. Кроме этого функции находятся в иерхиотичкской зависимости, тоесть чтобы функция ft_print_three могла передать данные в функцию ft_print_one она должна сначала передать их в ft_print_two которая после обработки данные может передавать только ft_print_one либо не передавать если соблюдены определенные условие (например числа от 10 до 19, 20, 30, 40, 50, 60, 70, 80, 90).

ft_get_word печатает слово из базы по переданному индексу строки. Он получив строку, находит ключ начала строки в данной задаче это ':' и печатает слово после этого символа. В данной реализации он печатает слово с пробелом перед ним, однако в будушем можно так-же добавить условие, чтобые пробел не стоял перед самым первым словом.

ft_get_tail анологичная функция с ft_get_word однако он печатает "хвосты" чисел получая при этом знаковый размер числа: например 0 - сотня, 1 - тысяча, 2 милион и тд. Данные обрабатываются 1 + (3 * div) формулой и исключение если div == 0 то работает логика для сотни.

кроме основных функциий есть и функции помощники для ft_print_three и ft_print_two и еще раз спасибо norminette за его ограничение в 25 строк. Функции помощники просто выносят часть логики из основной функции в отдельную для обеспечения длины в 25 строк.

## helper.c

ft_print_zero_helper функция помощник для трехзначных чисел. Предотвращает печать "хвоста" если в переданной тройке все "числа" равны 0. Предотвращение идет путем вызова функции ft_print_two но с передачей аргумента is_first равной 0.

ft_print_three_helper функция помощник для трехзначных чисел. вызывает ft_print_zero_helper если первый символ переданной трейке '0'. В противном случае проводит простую валидацию вызывая ft_get_word и ft_get_tail с нужными индексами для печати и после всего ft_print_two для дальнейшей обработки данных. В этой и последующих функций используем is_exit для принудительного выхода из цыкла поскольку многоуважаемый norminette запрещает использовать break.

ft_process_teen_digits логика поведения функции ft_print_two когда переданные числа находятся от 10 до 19

ft_process_tens_digits логика поведения функции ft_print_two когда переданные числа находятся от 20 до 99

## split.c

ft_split_content функция для переобразования переданных данных из файла в двумерный массив

ft_init_strs функция динамически создает двумерный массив 

ft_fill_strs функция заполняет созданный двумерный массив.

## utils_file.c

ft_read_file_data функция для открытия и прочтения данных и закрытия файла. Эта функция может читать файл любой длины и записывать их в массив. Функция читает данные 1024 байтов за раз и если он не дошел до конца файла он читает еще 1024 и так до конца. При этом он так же перемещает старые данные + новые в новый динамический массив освобождая страый.

ft_no_content функция отвечающая за закрытие файла и освобождение динамически выделенной памяти если произошла непредвиденная ошибка. // тут конечно я зря добавил освобождение поскольку в основном будет ошибка о выделении памяти и раз она не выделилась то и освобождять нечего. Надо было только закрыть файл, ну да дално.

ft_content функция которая и отвечает за динамическое расширение выделенной памяти для массива каждый раз расширяя его символ за символом передавая указатель на новый массив content у но перед этим освобождая старый массив content -а. // тут тоже я мог выделять память не по байтно а сразу обшее кол-во прочтенных байтов до этого t_b + текущее кол-во прочтенных байтов в данный момент r_b ну и 1 байт для конца строки.

## utils.c

ft_atoi крайне примитивный вариант валидации введенных чисел пользователем.

ft_putstr примитывный вариант вывода символа в консоль

ft_strlen примитывный вариант для получения длины переданного массива символов.